{"version":3,"file":"useInfiniteScroll-De2QmkUJ.js","sources":["../../src/hooks/useInfiniteScroll.js"],"sourcesContent":["import { useEffect, useCallback, useRef } from \"react\";\r\n\r\n/**\r\n * Reusable Infinite Scroll Hook\r\n * @param {React.RefObject} sentinelRef - Ref for the sentinel element at the bottom of the list\r\n * @param {Function} loadMore - Callback to load the next page\r\n * @param {boolean} hasMore - Whether there are more pages to fetch\r\n * @param {boolean} isLoading - Loading state to prevent concurrent fetches\r\n * @param {React.RefObject} containerRef - Optional scroll container ref\r\n */\r\nexport default function useInfiniteScroll(\r\n  sentinelRef,\r\n  loadMore,\r\n  hasMore,\r\n  isLoading,\r\n  containerRef = null\r\n) {\r\n  const observerRef = useRef(null);\r\n\r\n  // Stable callback for intersection observer\r\n  const handleIntersection = useCallback(\r\n    (entries) => {\r\n      const [entry] = entries;\r\n      \r\n      // Trigger loadMore only when:\r\n      // 1. Sentinel is intersecting (visible in viewport)\r\n      // 2. There are more pages available\r\n      // 3. Not currently loading\r\n      if (entry.isIntersecting && hasMore && !isLoading) {\r\n        loadMore();\r\n      }\r\n    },\r\n    [hasMore, isLoading, loadMore]\r\n  );\r\n\r\n  useEffect(() => {\r\n    // Get current DOM elements\r\n    const sentinel = sentinelRef?.current;\r\n    const container = containerRef?.current;\r\n\r\n    // Early return if sentinel doesn't exist\r\n    if (!sentinel) {\r\n      return;\r\n    }\r\n\r\n    // Disconnect existing observer before creating new one\r\n    if (observerRef.current) {\r\n      observerRef.current.disconnect();\r\n    }\r\n\r\n    // Create new IntersectionObserver\r\n    observerRef.current = new IntersectionObserver(handleIntersection, {\r\n      root: container || null, // Use container as root or viewport if null\r\n      rootMargin: \"200px\",     // Start loading 200px before sentinel is visible\r\n      threshold: 0.1,          // Trigger when 10% of sentinel is visible\r\n    });\r\n\r\n    // Start observing the sentinel\r\n    observerRef.current.observe(sentinel);\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      if (observerRef.current) {\r\n        observerRef.current.disconnect();\r\n        observerRef.current = null;\r\n      }\r\n    };\r\n  }, [sentinelRef, containerRef, handleIntersection]);\r\n\r\n  // No return value needed - this is a side-effect only hook\r\n}"],"names":["useInfiniteScroll","sentinelRef","loadMore","hasMore","isLoading","containerRef","observerRef","useRef","handleIntersection","useCallback","entries","entry","useEffect","sentinel","container"],"mappings":"wCAUe,SAASA,EACtBC,EACAC,EACAC,EACAC,EACAC,EAAe,KACf,CACA,MAAMC,EAAcC,SAAO,IAAI,EAGzBC,EAAqBC,EAAAA,YACxBC,GAAY,CACX,KAAM,CAACC,CAAK,EAAID,EAMZC,EAAM,gBAAkBR,GAAW,CAACC,GACtCF,GAEJ,EACA,CAACC,EAASC,EAAWF,CAAQ,CACjC,EAEEU,EAAAA,UAAU,IAAM,CAEd,MAAMC,EAAWZ,GAAa,QACxBa,EAAYT,GAAc,QAGhC,GAAKQ,EAKL,OAAIP,EAAY,SACdA,EAAY,QAAQ,aAItBA,EAAY,QAAU,IAAI,qBAAqBE,EAAoB,CACjE,KAAMM,GAAa,KACnB,WAAY,QACZ,UAAW,EACjB,CAAK,EAGDR,EAAY,QAAQ,QAAQO,CAAQ,EAG7B,IAAM,CACPP,EAAY,UACdA,EAAY,QAAQ,aACpBA,EAAY,QAAU,KAE1B,CACF,EAAG,CAACL,EAAaI,EAAcG,CAAkB,CAAC,CAGpD"}